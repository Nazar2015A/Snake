{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\user\\\\Desktop\\\\project\\\\snake\\\\front-end\\\\src\\\\components\\\\Board\\\\Board.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nimport { randomIntFromInterval, reverseLinkedList, useInterval } from '../../utils/utils';\nimport './Board.css';\n\n/**\r\n * TODO: add a more elegant UX for before a game starts and after a game ends.\r\n * A game probably shouldn't start until the user presses an arrow key, and\r\n * once a game is over, the board state should likely freeze until the user\r\n * intentionally restarts the game.\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\nclass LinkedList {\n  constructor(value) {\n    const node = new LinkedListNode(value);\n    this.head = node;\n    this.tail = node;\n  }\n}\nconst Direction = {\n  UP: 'UP',\n  RIGHT: 'RIGHT',\n  DOWN: 'DOWN',\n  LEFT: 'LEFT'\n};\nconst BOARD_SIZE = 10;\nconst getStartingSnakeLLValue = board => {\n  const rowSize = board.length;\n  const colSize = board[0].length;\n  const startingRow = Math.round(rowSize / 3);\n  const startingCol = Math.round(colSize / 3);\n  const startingCell = board[startingRow][startingCol];\n  return {\n    row: startingRow,\n    col: startingCol,\n    cell: startingCell\n  };\n};\nconst Board = () => {\n  _s();\n  const [score, setScore] = useState(0);\n  const board = createBoard(BOARD_SIZE);\n  const [snake, setSnake] = useState(new LinkedList(getStartingSnakeLLValue(board)));\n  const [snakeCells, setSnakeCells] = useState(new Set([snake.head.value.cell]));\n  // Naively set the starting food cell 5 cells away from the starting snake cell.\n  const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\n  const [direction, setDirection] = useState(Direction.RIGHT);\n  const [menu, setMenu] = useState(false);\n  useEffect(() => {\n    window.addEventListener('keydown', e => {\n      handleKeydown(e);\n    });\n  }, []);\n  useInterval(() => {\n    moveSnake();\n  }, 150);\n  const handleKeydown = e => {\n    const newDirection = getDirectionFromKey(e.key);\n    const isValidDirection = newDirection !== '';\n    if (!isValidDirection) return;\n    const snakeWillRunIntoItself = getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\n    if (snakeWillRunIntoItself) return;\n    setDirection(newDirection);\n  };\n  const moveSnake = () => {\n    const currentHeadCoords = {\n      row: snake.head.value.row,\n      col: snake.head.value.col\n    };\n    const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\n    if (isOutOfBounds(nextHeadCoords, board)) {\n      handleGameOver();\n      return;\n    }\n    const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\n    if (snakeCells.has(nextHeadCell)) {\n      handleGameOver();\n      return;\n    }\n    const newHead = new LinkedListNode({\n      row: nextHeadCoords.row,\n      col: nextHeadCoords.col,\n      cell: nextHeadCell\n    });\n    const currentHead = snake.head;\n    snake.head = newHead;\n    currentHead.next = newHead;\n    const newSnakeCells = new Set(snakeCells);\n    newSnakeCells.delete(snake.tail.value.cell);\n    newSnakeCells.add(nextHeadCell);\n    snake.tail = snake.tail.next;\n    if (snake.tail === null) snake.tail = snake.head;\n    const foodConsumed = nextHeadCell === foodCell;\n    if (foodConsumed) {\n      // This function mutates newSnakeCells.\n      growSnake(newSnakeCells);\n      handleFoodConsumption(newSnakeCells);\n    }\n    setSnakeCells(newSnakeCells);\n  };\n\n  // This function mutates newSnakeCells.\n  const growSnake = newSnakeCells => {\n    const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\n    if (isOutOfBounds(growthNodeCoords, board)) {\n      // Snake is positioned such that it can't grow; don't do anything.\n      return;\n    }\n    const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\n    const newTail = new LinkedListNode({\n      row: growthNodeCoords.row,\n      col: growthNodeCoords.col,\n      cell: newTailCell\n    });\n    const currentTail = snake.tail;\n    snake.tail = newTail;\n    snake.tail.next = currentTail;\n    newSnakeCells.add(newTailCell);\n  };\n  const handleFoodConsumption = newSnakeCells => {\n    const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\n    let nextFoodCell;\n    // In practice, this will never be a time-consuming operation. Even\n    // in the extreme scenario where a snake is so big that it takes up 90%\n    // of the board (nearly impossible), there would be a 10% chance of generating\n    // a valid new food cell--so an average of 10 operations: trivial.\n    while (true) {\n      nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\n      if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell) continue;\n      break;\n    }\n    setFoodCell(nextFoodCell);\n    setScore(score + 1);\n  };\n  const handleGameOver = () => {\n    setMenu(true);\n    // const snakeLLStartingValue = getStartingSnakeLLValue(board);\n    // setSnake(new LinkedList(snakeLLStartingValue));\n    // setFoodCell(snakeLLStartingValue.cell + 5);\n    // setSnakeCells(new Set([snakeLLStartingValue.cell]));\n    // setDirection(Direction.RIGHT);\n  };\n\n  const resumeGame = () => {\n    setMenu(false);\n    setScore(0);\n    const snakeLLStartingValue = getStartingSnakeLLValue(board);\n    setSnake(new LinkedList(snakeLLStartingValue));\n    setFoodCell(snakeLLStartingValue.cell + 5);\n    setSnakeCells(new Set([snakeLLStartingValue.cell]));\n    setDirection(Direction.RIGHT);\n  };\n  const createBoard = BOARD_SIZE => {\n    let counter = 1;\n    const board = [];\n    for (let row = 0; row < BOARD_SIZE; row++) {\n      const currentRow = [];\n      for (let col = 0; col < BOARD_SIZE; col++) {\n        currentRow.push(counter++);\n      }\n      board.push(currentRow);\n    }\n    return board;\n  };\n  const getCoordsInDirection = (coords, direction) => {\n    if (direction === Direction.UP) {\n      return {\n        row: coords.row - 1,\n        col: coords.col\n      };\n    }\n    if (direction === Direction.RIGHT) {\n      return {\n        row: coords.row,\n        col: coords.col + 1\n      };\n    }\n    if (direction === Direction.DOWN) {\n      return {\n        row: coords.row + 1,\n        col: coords.col\n      };\n    }\n    if (direction === Direction.LEFT) {\n      return {\n        row: coords.row,\n        col: coords.col - 1\n      };\n    }\n  };\n  const isOutOfBounds = (coords, board) => {\n    const {\n      row,\n      col\n    } = coords;\n    if (row < 0 || col < 0) return true;\n    if (row >= board.length || col >= board[0].length) return true;\n    return false;\n  };\n  const getDirectionFromKey = key => {\n    if (key === 'ArrowUp') return Direction.UP;\n    if (key === 'ArrowRight') return Direction.RIGHT;\n    if (key === 'ArrowDown') return Direction.DOWN;\n    if (key === 'ArrowLeft') return Direction.LEFT;\n    return '';\n  };\n  const getNextNodeDirection = (node, currentDirection) => {\n    if (node.next === null) return currentDirection;\n    const {\n      row: currentRow,\n      col: currentCol\n    } = node.value;\n    const {\n      row: nextRow,\n      col: nextCol\n    } = node.next.value;\n    if (nextRow === currentRow && nextCol === currentCol + 1) {\n      return Direction.RIGHT;\n    }\n    if (nextRow === currentRow && nextCol === currentCol - 1) {\n      return Direction.LEFT;\n    }\n    if (nextCol === currentCol && nextRow === currentRow + 1) {\n      return Direction.DOWN;\n    }\n    if (nextCol === currentCol && nextRow === currentRow - 1) {\n      return Direction.UP;\n    }\n    return '';\n  };\n  const getGrowthNodeCoords = (snakeTail, currentDirection) => {\n    const tailNextNodeDirection = getNextNodeDirection(snakeTail, currentDirection);\n    const growthDirection = getOppositeDirection(tailNextNodeDirection);\n    const currentTailCoords = {\n      row: snakeTail.value.row,\n      col: snakeTail.value.col\n    };\n    const growthNodeCoords = getCoordsInDirection(currentTailCoords, growthDirection);\n    return growthNodeCoords;\n  };\n  const getOppositeDirection = direction => {\n    if (direction === Direction.UP) return Direction.DOWN;\n    if (direction === Direction.RIGHT) return Direction.LEFT;\n    if (direction === Direction.DOWN) return Direction.UP;\n    if (direction === Direction.LEFT) return Direction.RIGHT;\n  };\n  const getCellClassName = (cellValue, foodCell, snakeCells) => {\n    let className = 'cell';\n    if (cellValue === foodCell) {\n      className = 'cell cell-red';\n    }\n    if (snakeCells.has(cellValue)) className = 'cell cell-green';\n    return className;\n  };\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [!menu && /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"Score: \", score]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 302,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"board\",\n      children: [board.map((row, rowIdx) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: row.map((cellValue, cellIdx) => {\n          const className = getCellClassName(cellValue, foodCell, snakeCells);\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            className: className\n          }, cellIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 312,\n            columnNumber: 22\n          }, this);\n        })\n      }, rowIdx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 305,\n        columnNumber: 11\n      }, this)), menu && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"board-menu\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"board-menu-score\",\n          children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n            className: \"board-menu-score-title\",\n            children: [\"Your Result: \", score]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 319,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"board-menu-score-btn\",\n            onClick: resumeGame,\n            children: \"Try again\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 320,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 318,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 303,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n_s(Board, \"PZPbnuJrBM0BKxRG3t1wJInq5L0=\", false, function () {\n  return [useInterval];\n});\n_c = Board;\nexport default Board;\nvar _c;\n$RefreshReg$(_c, \"Board\");","map":{"version":3,"names":["React","useEffect","useState","randomIntFromInterval","reverseLinkedList","useInterval","jsxDEV","_jsxDEV","Fragment","_Fragment","LinkedListNode","constructor","value","next","LinkedList","node","head","tail","Direction","UP","RIGHT","DOWN","LEFT","BOARD_SIZE","getStartingSnakeLLValue","board","rowSize","length","colSize","startingRow","Math","round","startingCol","startingCell","row","col","cell","Board","_s","score","setScore","createBoard","snake","setSnake","snakeCells","setSnakeCells","Set","foodCell","setFoodCell","direction","setDirection","menu","setMenu","window","addEventListener","e","handleKeydown","moveSnake","newDirection","getDirectionFromKey","key","isValidDirection","snakeWillRunIntoItself","getOppositeDirection","size","currentHeadCoords","nextHeadCoords","getCoordsInDirection","isOutOfBounds","handleGameOver","nextHeadCell","has","newHead","currentHead","newSnakeCells","delete","add","foodConsumed","growSnake","handleFoodConsumption","growthNodeCoords","getGrowthNodeCoords","newTailCell","newTail","currentTail","maxPossibleCellValue","nextFoodCell","resumeGame","snakeLLStartingValue","counter","currentRow","push","coords","getNextNodeDirection","currentDirection","currentCol","nextRow","nextCol","snakeTail","tailNextNodeDirection","growthDirection","currentTailCoords","getCellClassName","cellValue","className","children","fileName","_jsxFileName","lineNumber","columnNumber","map","rowIdx","cellIdx","onClick","_c","$RefreshReg$"],"sources":["C:/Users/user/Desktop/project/snake/front-end/src/components/Board/Board.jsx"],"sourcesContent":["import React, {useEffect, useState} from 'react';\r\nimport {\r\n  randomIntFromInterval,\r\n  reverseLinkedList,\r\n  useInterval,\r\n} from '../../utils/utils';\r\n\r\nimport './Board.css';\r\n\r\n/**\r\n * TODO: add a more elegant UX for before a game starts and after a game ends.\r\n * A game probably shouldn't start until the user presses an arrow key, and\r\n * once a game is over, the board state should likely freeze until the user\r\n * intentionally restarts the game.\r\n */\r\n\r\nclass LinkedListNode {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass LinkedList {\r\n  constructor(value) {\r\n    const node = new LinkedListNode(value);\r\n    this.head = node;\r\n    this.tail = node;\r\n  }\r\n}\r\n\r\nconst Direction = {\r\n  UP: 'UP',\r\n  RIGHT: 'RIGHT',\r\n  DOWN: 'DOWN',\r\n  LEFT: 'LEFT',\r\n};\r\n\r\nconst BOARD_SIZE = 10;\r\n\r\nconst getStartingSnakeLLValue = board => {\r\n  const rowSize = board.length;\r\n  const colSize = board[0].length;\r\n  const startingRow = Math.round(rowSize / 3);\r\n  const startingCol = Math.round(colSize / 3);\r\n  const startingCell = board[startingRow][startingCol];\r\n  return {\r\n    row: startingRow,\r\n    col: startingCol,\r\n    cell: startingCell,\r\n  };\r\n};\r\n\r\nconst Board = () => {\r\n  const [score, setScore] = useState(0);\r\n  const board = createBoard(BOARD_SIZE)\r\n  const [snake, setSnake] = useState(\r\n    new LinkedList(getStartingSnakeLLValue(board)),\r\n  );\r\n  const [snakeCells, setSnakeCells] = useState(\r\n    new Set([snake.head.value.cell]),\r\n  );\r\n  // Naively set the starting food cell 5 cells away from the starting snake cell.\r\n  const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\r\n  const [direction, setDirection] = useState(Direction.RIGHT);\r\n  const [menu, setMenu] = useState(false)\r\n  useEffect(() => {\r\n    window.addEventListener('keydown', e => {\r\n      handleKeydown(e);\r\n    });\r\n  }, []);\r\n\r\n  useInterval(() => {\r\n    moveSnake();\r\n  }, 150);\r\n\r\n  const handleKeydown = e => {\r\n    const newDirection = getDirectionFromKey(e.key);\r\n    const isValidDirection = newDirection !== '';\r\n    if (!isValidDirection) return;\r\n    const snakeWillRunIntoItself =\r\n      getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\r\n\r\n    if (snakeWillRunIntoItself) return;\r\n    setDirection(newDirection);\r\n  };\r\n\r\n  const moveSnake = () => {\r\n    const currentHeadCoords = {\r\n      row: snake.head.value.row,\r\n      col: snake.head.value.col,\r\n    };\r\n\r\n    const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\r\n    if (isOutOfBounds(nextHeadCoords, board)) {\r\n      handleGameOver();\r\n      return;\r\n    }\r\n    const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\r\n    if (snakeCells.has(nextHeadCell)) {\r\n      handleGameOver();\r\n      return;\r\n    }\r\n\r\n    const newHead = new LinkedListNode({\r\n      row: nextHeadCoords.row,\r\n      col: nextHeadCoords.col,\r\n      cell: nextHeadCell,\r\n    });\r\n    const currentHead = snake.head;\r\n    snake.head = newHead;\r\n    currentHead.next = newHead;\r\n\r\n    const newSnakeCells = new Set(snakeCells);\r\n    newSnakeCells.delete(snake.tail.value.cell);\r\n    newSnakeCells.add(nextHeadCell);\r\n\r\n    snake.tail = snake.tail.next;\r\n    if (snake.tail === null) snake.tail = snake.head;\r\n\r\n    const foodConsumed = nextHeadCell === foodCell;\r\n    if (foodConsumed) {\r\n      // This function mutates newSnakeCells.\r\n      growSnake(newSnakeCells);\r\n      handleFoodConsumption(newSnakeCells);\r\n    }\r\n\r\n    setSnakeCells(newSnakeCells);\r\n  };\r\n\r\n  // This function mutates newSnakeCells.\r\n  const growSnake = newSnakeCells => {\r\n    const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\r\n    if (isOutOfBounds(growthNodeCoords, board)) {\r\n      // Snake is positioned such that it can't grow; don't do anything.\r\n      return;\r\n    }\r\n    const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\r\n    const newTail = new LinkedListNode({\r\n      row: growthNodeCoords.row,\r\n      col: growthNodeCoords.col,\r\n      cell: newTailCell,\r\n    });\r\n    const currentTail = snake.tail;\r\n    snake.tail = newTail;\r\n    snake.tail.next = currentTail;\r\n\r\n    newSnakeCells.add(newTailCell);\r\n  };\r\n\r\n\r\n  const handleFoodConsumption = newSnakeCells => {\r\n    const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\r\n    let nextFoodCell;\r\n    // In practice, this will never be a time-consuming operation. Even\r\n    // in the extreme scenario where a snake is so big that it takes up 90%\r\n    // of the board (nearly impossible), there would be a 10% chance of generating\r\n    // a valid new food cell--so an average of 10 operations: trivial.\r\n    while (true) {\r\n      nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\r\n      if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell)\r\n        continue;\r\n      break;\r\n    }\r\n\r\n    setFoodCell(nextFoodCell);\r\n    setScore(score + 1);\r\n  };\r\n\r\n  const handleGameOver = () => {\r\n    setMenu(true)\r\n    // const snakeLLStartingValue = getStartingSnakeLLValue(board);\r\n    // setSnake(new LinkedList(snakeLLStartingValue));\r\n    // setFoodCell(snakeLLStartingValue.cell + 5);\r\n    // setSnakeCells(new Set([snakeLLStartingValue.cell]));\r\n    // setDirection(Direction.RIGHT);\r\n\r\n  };\r\n\r\n  const resumeGame = () => {\r\n    setMenu(false)\r\n    setScore(0)\r\n    const snakeLLStartingValue = getStartingSnakeLLValue(board);\r\n    setSnake(new LinkedList(snakeLLStartingValue));\r\n    setFoodCell(snakeLLStartingValue.cell + 5);\r\n    setSnakeCells(new Set([snakeLLStartingValue.cell]));\r\n    setDirection(Direction.RIGHT);\r\n  }\r\n  const createBoard = BOARD_SIZE => {\r\n    let counter = 1;\r\n    const board = [];\r\n    for (let row = 0; row < BOARD_SIZE; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < BOARD_SIZE; col++) {\r\n        currentRow.push(counter++);\r\n      }\r\n      board.push(currentRow);\r\n    }\r\n    return board;\r\n  };\r\n  \r\n  const getCoordsInDirection = (coords, direction) => {\r\n    if (direction === Direction.UP) {\r\n      return {\r\n        row: coords.row - 1,\r\n        col: coords.col,\r\n      };\r\n    }\r\n    if (direction === Direction.RIGHT) {\r\n      return {\r\n        row: coords.row,\r\n        col: coords.col + 1,\r\n      };\r\n    }\r\n    if (direction === Direction.DOWN) {\r\n      return {\r\n        row: coords.row + 1,\r\n        col: coords.col,\r\n      };\r\n    }\r\n    if (direction === Direction.LEFT) {\r\n      return {\r\n        row: coords.row,\r\n        col: coords.col - 1,\r\n      };\r\n    }\r\n  };\r\n  \r\n  const isOutOfBounds = (coords, board) => {\r\n    const {row, col} = coords;\r\n    if (row < 0 || col < 0) return true;\r\n    if (row >= board.length || col >= board[0].length) return true;\r\n    return false;\r\n  };\r\n  \r\n  const getDirectionFromKey = key => {\r\n    if (key === 'ArrowUp') return Direction.UP;\r\n    if (key === 'ArrowRight') return Direction.RIGHT;\r\n    if (key === 'ArrowDown') return Direction.DOWN;\r\n    if (key === 'ArrowLeft') return Direction.LEFT;\r\n    return '';\r\n  };\r\n  \r\n  const getNextNodeDirection = (node, currentDirection) => {\r\n    if (node.next === null) return currentDirection;\r\n    const {row: currentRow, col: currentCol} = node.value;\r\n    const {row: nextRow, col: nextCol} = node.next.value;\r\n    if (nextRow === currentRow && nextCol === currentCol + 1) {\r\n      return Direction.RIGHT;\r\n    }\r\n    if (nextRow === currentRow && nextCol === currentCol - 1) {\r\n      return Direction.LEFT;\r\n    }\r\n    if (nextCol === currentCol && nextRow === currentRow + 1) {\r\n      return Direction.DOWN;\r\n    }\r\n    if (nextCol === currentCol && nextRow === currentRow - 1) {\r\n      return Direction.UP;\r\n    }\r\n    return '';\r\n  };\r\n  \r\n  const getGrowthNodeCoords = (snakeTail, currentDirection) => {\r\n    const tailNextNodeDirection = getNextNodeDirection(\r\n      snakeTail,\r\n      currentDirection,\r\n    );\r\n    const growthDirection = getOppositeDirection(tailNextNodeDirection);\r\n    const currentTailCoords = {\r\n      row: snakeTail.value.row,\r\n      col: snakeTail.value.col,\r\n    };\r\n    const growthNodeCoords = getCoordsInDirection(\r\n      currentTailCoords,\r\n      growthDirection,\r\n    );\r\n    return growthNodeCoords;\r\n  };\r\n  \r\n  const getOppositeDirection = direction => {\r\n    if (direction === Direction.UP) return Direction.DOWN\r\n    if (direction === Direction.RIGHT) return Direction.LEFT;\r\n    if (direction === Direction.DOWN) return Direction.UP;\r\n    if (direction === Direction.LEFT) return Direction.RIGHT;\r\n  };\r\n  \r\n  const getCellClassName = (\r\n    cellValue,\r\n    foodCell,\r\n    snakeCells,\r\n  ) => {\r\n    let className = 'cell';\r\n    if (cellValue === foodCell) {\r\n      className = 'cell cell-red';\r\n    }\r\n    if (snakeCells.has(cellValue)) className = 'cell cell-green';\r\n  \r\n    return className;\r\n  };\r\n  return (\r\n    <>\r\n      {!menu && <h1>Score: {score}</h1>}\r\n      <div className=\"board\">\r\n        {board.map((row, rowIdx) => (\r\n          <div key={rowIdx} className=\"row\">\r\n            {row.map((cellValue, cellIdx) => {\r\n              const className = getCellClassName(\r\n                cellValue,\r\n                foodCell,\r\n                snakeCells,\r\n              );\r\n              return <div key={cellIdx} className={className}></div>;\r\n            })}\r\n          </div>\r\n        ))}\r\n        {menu && (\r\n        <div className='board-menu'>\r\n          <div className='board-menu-score'>\r\n            <h1 className='board-menu-score-title'>Your Result: {score}</h1>\r\n            <button className='board-menu-score-btn' onClick={resumeGame}>Try again</button>\r\n          </div>\r\n        </div>\r\n      )}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\n\r\n\r\nexport default Board;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}